{"version":3,"sources":["webpack:///./src/pages/posts/2019-05-19-sobel/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","MDXContent","components","props","mdxType","className","href","parentName","transformType","style","src","colourWheel","alt","isMDXComponent"],"mappings":"oRAUO,IAAMA,EAAe,CAC1B,MAAS,uBACT,SAAY,mEACZ,KAAQ,aACR,MAAS,mBAQLC,EAAc,CAClBD,gBAEIE,EAAY,UACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,cAACH,EAAD,iBAAeD,EAAiBI,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAE5E,+CAA4B,mBAAGC,UAAU,WAAWC,KAAK,gCAA7B,+BAA5B,gGAA4N,mBAAGA,KAAK,+CAA+CD,UAAU,YAAjE,mBAA5N,sPACA,sEAAmD,mBAAGC,KAAK,0CAA0CD,UAAU,YAA5D,aAAnD,qEACA,yBAAK,oCAAME,WAAW,OAAU,CAC5B,UAAa,wBADZ,k7BA+BL,cAAC,IAAD,CAAaC,cAAc,YAAYJ,QAAQ,gBAC/C,qEAAkD,mBAAGC,UAAU,WAAWC,KAAK,uEAA7B,YAAlD,2BAAiM,mBAAGD,UAAU,WAAWC,KAAK,2DAA7B,WAAjM,KAA6S,4BAAYC,WAAW,KAAvB,MAA7S,QAAoW,4BAAYA,WAAW,KAAvB,MAApW,6GAAggB,4BAAYA,WAAW,KAAvB,MAAhgB,gIAA+qB,4BAAYA,WAAW,KAAvB,MAA/qB,oEAAkyB,4BAAYA,WAAW,KAAvB,MAAlyB,QAAy1B,4BAAYA,WAAW,KAAvB,MAAz1B,2HACA,yBAAK,oCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qKAML,8FAA2E,4BAAYA,WAAW,KAAvB,yBAA3E,4JACA,cAAC,IAAD,CAAaC,cAAc,QAAQJ,QAAQ,gBAC3C,qBAAKC,UAAWI,cAAmBC,IAAKC,IAAaC,IAAI,iBACzD,oIAAiH,4BAAYL,WAAW,KAAvB,mBAAjH,yHACA,cAAC,IAAD,CAAaC,cAAc,cAAcJ,QAAQ,gBACjD,sHACA,kQACA,cAAC,IAAD,CAAWA,QAAQ,cACnB,sDACA,wBACE,oBAAIG,WAAW,MAAK,mBAAGF,UAAU,WAAWC,KAAK,gCAA7B,uDACpB,oBAAIC,WAAW,MAAK,mBAAGF,UAAU,WAAWC,KAAK,gEAA7B,gCAM1BL,EAAWY,gBAAiB","file":"component---src-pages-posts-2019-05-19-sobel-index-mdx-7cc49cd624c4a5d11d99.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport FlowerSobel from \"../../../components/posts/sobel/sobelFlower/sobelFlower\";\nimport SobelTool from \"../../../components/posts/sobel/sobelTool/sobelTool\";\nimport colourWheel from \"../../../../static/colourWheel.png\";\nimport * as style from './style.module.css';\nimport * as commonStyle from \"../common.module.css\";\nexport const _frontmatter = {\n  \"title\": \"Sobel Edge Detection\",\n  \"subtitle\": \"A look at Sobel edge detection using HTML canvas and JavaScript.\",\n  \"date\": \"2019-05-19\",\n  \"image\": \"sobelFlower.png\"\n};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <p>{`I recently watched a `}<a className=\"blueLink\" href=\"https://youtu.be/uihBwtPIBxM\">{`Computerphile YouTube video`}</a>{` about Sobel edge detection and thought I'd write a post about it. In Sobel edge detection a `}<a href=\"https://en.wikipedia.org/wiki/Sobel_operator\" className=\"blueLink\">{`Sobel operation`}</a>{` is applied to an image in order to detect shapes/edges in the image. The main application of edge detection is in robotic vision, for example allowing self-driving vehicles to detect motorway lanes, but it can be used for any image analysis.`}</p>\n    <p>{`The first step in the Sobel operation is to `}<a href=\"https://en.wikipedia.org/wiki/Grayscale\" className=\"blueLink\">{`greyscale`}</a>{` the image. This can be done with a few lines of JavaScript code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var gsFigure = document.querySelector(\"#fig-greyscale\");\nvar gsImage = gsFigure.querySelector(\"img\");\nvar gsCanvas = gsFigure.querySelector(\"canvas\");\nvar gsbutton = gsFigure.querySelector(\".button\");\nvar gsCtx = gsCanvas.getContext(\"2d\");\n\ngsbutton.addEventListener(\"click\", () => {\n  gsCanvas.width = gsImage.width;\n  gsCanvas.height = gsImage.height;\n  gsCtx.drawImage(gsImage, 0, 0);\n  var gsImageData = gsCtx.getImageData(0, 0, gsCanvas.width, gsCanvas.height);\n  var id = greyScale(gsImageData);\n  gsCtx.putImageData(id, 0, 0);\n}\n\nfunction greyScale (imageData) {\n  var d = imageData.data;\n  for (var i=0; i<d.length; i+=4) {\n    var r = d[i];\n    var g = d[i+1];\n    var b = d[i+2];\n    // CIE luminance for RGB\n    // Human vision is most sensitive to green, so this has the greatest coefficient value.\n    var v = 0.2126*r + 0.7152*g + 0.0722*b;\n    d[i] = d[i+1] = d[i+2] = v\n  }\n  return imageData;\n};\n`}</code></pre>\n    <FlowerSobel transformType=\"greyscale\" mdxType=\"FlowerSobel\" />\n    <p>{`The next step in the Sobel operation is to `}<a className=\"blueLink\" href=\"https://en.wikipedia.org/wiki/Kernel_(image_processing)#Convolution\">{`convolve`}</a>{` the image with two 3x3 `}<a className=\"blueLink\" href=\"https://en.wikipedia.org/wiki/Kernel_(image_processing)\">{`kernels`}</a>{`, `}<inlineCode parentName=\"p\">{`Gx`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Gy`}</inlineCode>{`. What this basically means is the strength of each pixel is weighted by its neighbours. The magnitude of `}<inlineCode parentName=\"p\">{`Gx`}</inlineCode>{` is greatest when the pixels to the right and left of the pixel being convolved are most different, whereas the magnitude of `}<inlineCode parentName=\"p\">{`Gy`}</inlineCode>{` is greatest when the pixels above and below are most different. `}<inlineCode parentName=\"p\">{`Gx`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Gy`}</inlineCode>{` can therefore be considered gradient functions and effectively emphasise edges in the x and y directions respectively.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`     |-1 0 +1|               |-1 -2 -1|\nGx = |-2 0 +2| * A  ,   Gy = | 0  0  0| * A  ,  where A is the source image.\n     |-1 0 +1|               |+1 +2 +1|\n`}</code></pre>\n    <p>{`The gradient functions can be combined to form a gradient magnitude `}<inlineCode parentName=\"p\">{`G = sqrt(Gx^2 + Gy^2)`}</inlineCode>{`. This produces an image where all the areas with large changes in pixel intensity (edges) are highlighted, just hit the button below to see an example:`}</p>\n    <FlowerSobel transformType=\"sobel\" mdxType=\"FlowerSobel\" />\n    <img className={style.colourWheel} src={colourWheel} alt=\"colour wheel\" />\n    <p>{`In fact we can even find out the orientation of the edges by taking the arctan of the gradient functions, `}<inlineCode parentName=\"p\">{`Î¸ = atan(Gy/Gx)`}</inlineCode>{`. The orientation can then be mapped to a colour using a colour wheel. Try running the example Sobel operation below:`}</p>\n    <FlowerSobel transformType=\"sobelColour\" mdxType=\"FlowerSobel\" />\n    <p>{`Wow that's pretty fancy! Notice how the edges orientation maps to that of the colour wheel.`}</p>\n    <p>{`Finally have a play with the JavaScript tool below allowing you to create your own Sobel images. The saturation input controls the amount of orientational colour added. Also I've set it to scale the images to 600px for performance.`}</p>\n    <SobelTool mdxType=\"SobelTool\" />\n    <h2>{`Further reading / watching`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a className=\"blueLink\" href=\"https://youtu.be/uihBwtPIBxM\">Finding the Edges (Sobel Operator) - Computerphile</a></li>\n      <li parentName=\"ul\"><a className=\"blueLink\" href=\"https://www.html5rocks.com/en/tutorials/canvas/imagefilters/\">Image Filters with Canvas</a></li>\n    </ul>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}