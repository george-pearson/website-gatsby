(self.webpackChunkblog=self.webpackChunkblog||[]).push([[456],{9756:function(e,n,a){"use strict";function r(e,n){if(null==e)return{};var a,r,t={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||(t[a]=e[a]);return t}a.d(n,{Z:function(){return r}})},2496:function(e,n,a){"use strict";a.r(n),a.d(n,{_frontmatter:function(){return o},default:function(){return s}});var r=a(9756),t=(a(7294),a(3497)),i=a(6295),o={title:"The Game Of Life",subtitle:"A post about Conway's Game Of Life, and some JavaScript code to simulate it.",date:"2019-04-06",image:"/gol.png"},l={_frontmatter:o};function s(e){var n=e.components,a=(0,r.Z)(e,["components"]);return(0,t.mdx)("wrapper",Object.assign({},l,a,{components:n,mdxType:"MDXLayout"}),(0,t.mdx)("p",null,"The ",(0,t.mdx)("a",{className:"blueLink",href:"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life"},"Game of Life")," is a ",(0,t.mdx)("a",{className:"blueLink",href:"https://en.wikipedia.org/wiki/Cellular_automaton"},"cellular automataton")," designed by the British mathematician ",(0,t.mdx)("a",{className:"blueLink",href:"https://en.wikipedia.org/wiki/John_Horton_Conway"},"John Conway"),'. A cellular automataton is a mathematical model that consists of a grid of cells, with each cell having an finite number of states (e.g "on" or "off"). A new grid configuration (a new ',(0,t.mdx)("em",{parentName:"p"},"generation"),") is created according to a fixed set of rules that determine the state of each cell based on its current state and the state of the cells around it (its ",(0,t.mdx)("em",{parentName:"p"},"neighbourhood"),"). Cellular automata can be used to simulate a variety of real-world systems, from the ",(0,t.mdx)("a",{className:"blueLink",href:"https://en.wikipedia.org/wiki/Belousov%E2%80%93Zhabotinsky_reaction"},"Belousovâ€“Zhabotinsky reaction")," to ",(0,t.mdx)("a",{className:"blueLink",href:"https://blogs.msdn.microsoft.com/calvin_hsia/2014/09/30/fish-vs-sharks-predator-prey-simulation/"},"predator prey relationships"),"."),(0,t.mdx)("p",null,"In Conway's Game of Life, the grid is a 2D array of square cells each with two states ",(0,t.mdx)("em",{parentName:"p"},"alive")," and ",(0,t.mdx)("em",{parentName:"p"},"dead"),". Each cell interacts with its 8 neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent to it. The rules are:"),(0,t.mdx)("ul",null,(0,t.mdx)("li",{parentName:"ul"},"Any live cell with fewer than two live neighbours dies, as if by underpopulation."),(0,t.mdx)("li",{parentName:"ul"},"Any live cell with two or three live neighbours lives on to the next generation."),(0,t.mdx)("li",{parentName:"ul"},"Any live cell with more than three live neighbours dies, as if by overpopulation."),(0,t.mdx)("li",{parentName:"ul"},"Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.")),(0,t.mdx)("p",null,"We can get the number of alive neighbours of a cell in 2D array with the code below. Note we are applying ",(0,t.mdx)("a",{href:"https://en.wikipedia.org/wiki/Periodic_boundary_conditions",className:"blueLink"},"periodic boundary conditions")," in both the x and y directions."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-javascript"},"var ALIVE = 1;\nvar DEAD = 0;\nvar N = 200;\nvar arr = create2Darray(N, N, DEAD); // Iitialises a new 2D array with array values set to 0.\nvar neighbourhood = [\n  [1, 0],\n  [1, 1],\n  [0, 1],\n  [-1, 1],\n  [-1, 0],\n  [-1, -1],\n  [0, -1],\n  [1, -1],\n];\n\n// Get number of ALIVE neighbours for point (x,y)\nfunction getneighcount(arr, x, y) {\n  var nc = 0;\n  for (var nn = 0; nn < neighbourhood.length; nn++) {\n    var dx = neighbourhood[nn][0];\n    var dy = neighbourhood[nn][1];\n    if (arr[pbcz(x + dx, arr.length)][pbcz(y + dy, arr[x].length)] === ALIVE) {\n      nc++;\n    }\n  }\n  return nc;\n}\n\n// Periodic boundary conditions in z-direction:\nfunction pbcz(iz, Lz) {\n  if (iz >= Lz) {\n    iz = iz - Lz;\n  }\n  if (iz < 0) {\n    iz = iz + Lz;\n  }\n  return iz;\n}\n")),(0,t.mdx)("p",null,"Then we can just turn the Game of Life rules into some simple JavaScript code:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-javascript"},"var ALIVE = 1;\nvar DEAD = 0;\nvar N = 200;\nvar arr = create2Darray(N, N, DEAD); // Iitialises a new 2D array with array values set to 0.\nvar requestId;\ngameLoop();\n\n// Runs forever, call cancelAnimationFrame(requestId) to stop.\nfunction gameLoop() {\n  arr = iterate(arr);\n  print_to_canvas(arr);\n  requestId = requestAnimationFrame(gameLoop);\n}\n\n// Iterate the next state of the array.\nfunction iterate(oldArray) {\n  var newArray = clone2Darray(oldArray);\n  for (var x = 0; x < oldArray.length; x++) {\n    for (var y = 0; y < oldArray[0].length; y++) {\n      var aliveNeighbourCount = getneighcount(oldArray, x, y);\n      if (oldArray[x][y] === ALIVE) {\n        if (aliveNeighbourCount < 2) {\n          newArray[x][y] = DEAD; // Underpopulation kills cell.\n        } else if (aliveNeighbourCount === 2 || aliveNeighbourCount === 3) {\n          newArray[x][y] = ALIVE; // Surivies!\n        } else if (aliveNeighbourCount > 3) {\n          newArray[x][y] = DEAD; // Overpopulation kills cell.\n        }\n      } else if (oldArray[x][y] === DEAD && aliveNeighbourCount === 3) {\n        newArray[x][y] = ALIVE; // Reproduction.\n      }\n    }\n  }\n  return newArray;\n}\n")),(0,t.mdx)("p",null,"I've packaged the Game of Life code up into interactive tool below."),(0,t.mdx)(i.Z,{mdxType:"GOLTool"}),(0,t.mdx)("p",null,"The full code for this tool is available on my ",(0,t.mdx)("a",{href:"https://github.com/george-pearson",className:"blueLink"},"GitHub"),"."))}s.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-posts-2019-04-06-the-game-of-life-index-mdx-31b9ae9d8f2675458038.js.map