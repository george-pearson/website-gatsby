{"version":3,"file":"component---src-pages-posts-2019-04-06-the-game-of-life-index-mdx-96625d1901afba4085ad.js","mappings":"4OAMaA,EAAe,CAC1B,MAAS,mBACT,SAAY,+EACZ,KAAQ,aACR,MAAS,YAELC,EAAc,CAClBD,aAAAA,GAGa,SAASE,EAAW,GAGhC,IAFDC,EAAU,EAAVA,WACGC,GAAK,YAER,OAAO,SALS,UAKC,iBAAKH,EAAiBG,EAAK,CAAED,WAAYA,EAAYE,QAAQ,eAE5E,0BAAW,cAAGC,UAAU,WAAWC,KAAK,yDAAuD,gBAAqB,UAAU,cAAGD,UAAU,WAAWC,KAAK,oDAAkD,wBAA6B,2CAA2C,cAAGD,UAAU,WAAWC,KAAK,oDAAkD,eAAoB,6LAA6L,eAAIC,WAAW,KAAG,cAAoB,8JAA8J,eAAIA,WAAW,KAAG,iBAAuB,2FAA2F,cAAGF,UAAU,WAAWC,KAAK,uEAAqE,iCAAsC,QAAQ,cAAGD,UAAU,WAAWC,KAAK,oGAAkG,+BAAoC,MAChrC,4GAA6F,eAAIC,WAAW,KAAG,SAAe,SAAS,eAAIA,WAAW,KAAG,QAAc,qJACvK,oBACE,eAAIA,WAAW,MAAI,sFACnB,eAAIA,WAAW,MAAI,qFACnB,eAAIA,WAAW,MAAI,sFACnB,eAAIA,WAAW,MAAI,kGAErB,gIAAiH,cAAGD,KAAK,6DAA6DD,UAAU,YAAU,gCAAqC,qCAC/O,qBAAK,iBAAME,WAAW,MAClB,UAAa,uBAAqB,+xBAwCtC,qGACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,uBAAqB,irCAqCtC,0FACA,SAAC,IAAO,CAACH,QAAQ,aACjB,qEAAsD,cAAGE,KAAK,oCAAoCD,UAAU,YAAU,UAAe,KAGzI,CAEAJ,EAAWO,gBAAiB,C,uBCtHb,SAASC,EAA8BC,EAAQC,GAC5D,GAAc,MAAVD,EAAgB,MAAO,CAAC,EAC5B,IAEIE,EAAKC,EAFLC,EAAS,CAAC,EACVC,EAAaC,OAAOC,KAAKP,GAE7B,IAAKG,EAAI,EAAGA,EAAIE,EAAWG,OAAQL,IACjCD,EAAMG,EAAWF,GACbF,EAASQ,QAAQP,IAAQ,IAC7BE,EAAOF,GAAOF,EAAOE,IAEvB,OAAOE,CACT,C","sources":["webpack://blog/./src/pages/posts/2019-04-06-the-game-of-life/index.mdx","webpack://blog/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport GOLTool from \"../../../components/posts/golTool/golTool\";\nexport const _frontmatter = {\n  \"title\": \"The Game Of Life\",\n  \"subtitle\": \"A post about Conway's Game Of Life, and some JavaScript code to simulate it.\",\n  \"date\": \"2019-04-06\",\n  \"image\": \"/gol.png\"\n};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <p>{`The `}<a className=\"blueLink\" href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\">{`Game of Life`}</a>{` is a `}<a className=\"blueLink\" href=\"https://en.wikipedia.org/wiki/Cellular_automaton\">{`cellular automataton`}</a>{` designed by the British mathematician `}<a className=\"blueLink\" href=\"https://en.wikipedia.org/wiki/John_Horton_Conway\">{`John Conway`}</a>{`. A cellular automataton is a mathematical model that consists of a grid of cells, with each cell having an finite number of states (e.g \"on\" or \"off\"). A new grid configuration (a new `}<em parentName=\"p\">{`generation`}</em>{`) is created according to a fixed set of rules that determine the state of each cell based on its current state and the state of the cells around it (its `}<em parentName=\"p\">{`neighbourhood`}</em>{`). Cellular automata can be used to simulate a variety of real-world systems, from the `}<a className=\"blueLink\" href=\"https://en.wikipedia.org/wiki/Belousov%E2%80%93Zhabotinsky_reaction\">{`Belousovâ€“Zhabotinsky reaction`}</a>{` to `}<a className=\"blueLink\" href=\"https://blogs.msdn.microsoft.com/calvin_hsia/2014/09/30/fish-vs-sharks-predator-prey-simulation/\">{`predator prey relationships`}</a>{`.`}</p>\n    <p>{`In Conway's Game of Life, the grid is a 2D array of square cells each with two states `}<em parentName=\"p\">{`alive`}</em>{` and `}<em parentName=\"p\">{`dead`}</em>{`. Each cell interacts with its 8 neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent to it. The rules are:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Any live cell with fewer than two live neighbours dies, as if by underpopulation.`}</li>\n      <li parentName=\"ul\">{`Any live cell with two or three live neighbours lives on to the next generation.`}</li>\n      <li parentName=\"ul\">{`Any live cell with more than three live neighbours dies, as if by overpopulation.`}</li>\n      <li parentName=\"ul\">{`Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.`}</li>\n    </ul>\n    <p>{`We can get the number of alive neighbours of a cell in 2D array with the code below. Note we are applying `}<a href=\"https://en.wikipedia.org/wiki/Periodic_boundary_conditions\" className=\"blueLink\">{`periodic boundary conditions`}</a>{` in both the x and y directions.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var ALIVE = 1;\nvar DEAD = 0;\nvar N = 200;\nvar arr = create2Darray(N, N, DEAD); // Iitialises a new 2D array with array values set to 0.\nvar neighbourhood = [\n  [1, 0],\n  [1, 1],\n  [0, 1],\n  [-1, 1],\n  [-1, 0],\n  [-1, -1],\n  [0, -1],\n  [1, -1],\n];\n\n// Get number of ALIVE neighbours for point (x,y)\nfunction getneighcount(arr, x, y) {\n  var nc = 0;\n  for (var nn = 0; nn < neighbourhood.length; nn++) {\n    var dx = neighbourhood[nn][0];\n    var dy = neighbourhood[nn][1];\n    if (arr[pbcz(x + dx, arr.length)][pbcz(y + dy, arr[x].length)] === ALIVE) {\n      nc++;\n    }\n  }\n  return nc;\n}\n\n// Periodic boundary conditions in z-direction:\nfunction pbcz(iz, Lz) {\n  if (iz >= Lz) {\n    iz = iz - Lz;\n  }\n  if (iz < 0) {\n    iz = iz + Lz;\n  }\n  return iz;\n}\n`}</code></pre>\n    <p>{`Then we can just turn the Game of Life rules into some simple JavaScript code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var ALIVE = 1;\nvar DEAD = 0;\nvar N = 200;\nvar arr = create2Darray(N, N, DEAD); // Iitialises a new 2D array with array values set to 0.\nvar requestId;\ngameLoop();\n\n// Runs forever, call cancelAnimationFrame(requestId) to stop.\nfunction gameLoop() {\n  arr = iterate(arr);\n  print_to_canvas(arr);\n  requestId = requestAnimationFrame(gameLoop);\n}\n\n// Iterate the next state of the array.\nfunction iterate(oldArray) {\n  var newArray = clone2Darray(oldArray);\n  for (var x = 0; x < oldArray.length; x++) {\n    for (var y = 0; y < oldArray[0].length; y++) {\n      var aliveNeighbourCount = getneighcount(oldArray, x, y);\n      if (oldArray[x][y] === ALIVE) {\n        if (aliveNeighbourCount < 2) {\n          newArray[x][y] = DEAD; // Underpopulation kills cell.\n        } else if (aliveNeighbourCount === 2 || aliveNeighbourCount === 3) {\n          newArray[x][y] = ALIVE; // Surivies!\n        } else if (aliveNeighbourCount > 3) {\n          newArray[x][y] = DEAD; // Overpopulation kills cell.\n        }\n      } else if (oldArray[x][y] === DEAD && aliveNeighbourCount === 3) {\n        newArray[x][y] = ALIVE; // Reproduction.\n      }\n    }\n  }\n  return newArray;\n}\n`}</code></pre>\n    <p>{`I've packaged the Game of Life code up into interactive tool below.`}</p>\n    <GOLTool mdxType=\"GOLTool\" />\n    <p>{`The full code for this tool is available on my `}<a href=\"https://github.com/george-pearson\" className=\"blueLink\">{`GitHub`}</a>{`.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}"],"names":["_frontmatter","layoutProps","MDXContent","components","props","mdxType","className","href","parentName","isMDXComponent","_objectWithoutPropertiesLoose","source","excluded","key","i","target","sourceKeys","Object","keys","length","indexOf"],"sourceRoot":""}