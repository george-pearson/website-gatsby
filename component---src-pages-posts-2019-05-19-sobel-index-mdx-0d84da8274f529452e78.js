(self.webpackChunkblog=self.webpackChunkblog||[]).push([[545],{9756:function(e,t,a){"use strict";function n(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}a.d(t,{Z:function(){return n}})},1434:function(e,t,a){"use strict";a.r(t),a.d(t,{_frontmatter:function(){return d},default:function(){return g}});var n=a(9756),i=(a(7294),a(3497)),o=a(2838),r=a(1959),s=a(8156),l=a(1104),d={title:"Sobel Edge Detection",subtitle:"A look at Sobel edge detection using HTML canvas and JavaScript.",date:"2019-05-19",image:"/sobelFlower.png"},m={_frontmatter:d};function g(e){var t=e.components,a=(0,n.Z)(e,["components"]);return(0,i.mdx)("wrapper",Object.assign({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"I recently watched a ",(0,i.mdx)("a",{className:"blueLink",href:"https://youtu.be/uihBwtPIBxM"},"Computerphile YouTube video")," about Sobel edge detection and thought I'd write a post about it. In Sobel edge detection a ",(0,i.mdx)("a",{href:"https://en.wikipedia.org/wiki/Sobel_operator",className:"blueLink"},"Sobel operation")," is applied to an image in order to detect shapes/edges in the image. The main application of edge detection is in robotic vision, for example allowing self-driving vehicles to detect motorway lanes, but it can be used for any image analysis."),(0,i.mdx)("p",null,"The first step in the Sobel operation is to ",(0,i.mdx)("a",{href:"https://en.wikipedia.org/wiki/Grayscale",className:"blueLink"},"greyscale")," the image. This can be done with a few lines of JavaScript code:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-javascript"},'var gsFigure = document.querySelector("#fig-greyscale");\nvar gsImage = gsFigure.querySelector("img");\nvar gsCanvas = gsFigure.querySelector("canvas");\nvar gsbutton = gsFigure.querySelector(".button");\nvar gsCtx = gsCanvas.getContext("2d");\n\ngsbutton.addEventListener("click", () => {\n  gsCanvas.width = gsImage.width;\n  gsCanvas.height = gsImage.height;\n  gsCtx.drawImage(gsImage, 0, 0);\n  var gsImageData = gsCtx.getImageData(0, 0, gsCanvas.width, gsCanvas.height);\n  var id = greyScale(gsImageData);\n  gsCtx.putImageData(id, 0, 0);\n}\n\nfunction greyScale (imageData) {\n  var d = imageData.data;\n  for (var i=0; i<d.length; i+=4) {\n    var r = d[i];\n    var g = d[i+1];\n    var b = d[i+2];\n    // CIE luminance for RGB\n    // Human vision is most sensitive to green, so this has the greatest coefficient value.\n    var v = 0.2126*r + 0.7152*g + 0.0722*b;\n    d[i] = d[i+1] = d[i+2] = v\n  }\n  return imageData;\n};\n')),(0,i.mdx)(o.Z,{transformType:"greyscale",mdxType:"FlowerSobel"}),(0,i.mdx)("p",null,"The next step in the Sobel operation is to ",(0,i.mdx)("a",{className:"blueLink",href:"https://en.wikipedia.org/wiki/Kernel_(image_processing)#Convolution"},"convolve")," the image with two 3x3 ",(0,i.mdx)("a",{className:"blueLink",href:"https://en.wikipedia.org/wiki/Kernel_(image_processing)"},"kernels"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"Gx")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"Gy"),". What this basically means is the strength of each pixel is weighted by its neighbours. The magnitude of ",(0,i.mdx)("inlineCode",{parentName:"p"},"Gx")," is greatest when the pixels to the right and left of the pixel being convolved are most different, whereas the magnitude of ",(0,i.mdx)("inlineCode",{parentName:"p"},"Gy")," is greatest when the pixels above and below are most different. ",(0,i.mdx)("inlineCode",{parentName:"p"},"Gx")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"Gy")," can therefore be considered gradient functions and effectively emphasise edges in the x and y directions respectively."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-javascript"},"     |-1 0 +1|               |-1 -2 -1|\nGx = |-2 0 +2| * A  ,   Gy = | 0  0  0| * A  ,  where A is the source image.\n     |-1 0 +1|               |+1 +2 +1|\n")),(0,i.mdx)("p",null,"The gradient functions can be combined to form a gradient magnitude ",(0,i.mdx)("inlineCode",{parentName:"p"},"G = sqrt(Gx^2 + Gy^2)"),". This produces an image where all the areas with large changes in pixel intensity (edges) are highlighted, just hit the button below to see an example:"),(0,i.mdx)(o.Z,{transformType:"sobel",mdxType:"FlowerSobel"}),(0,i.mdx)("img",{className:l.colourWheel,src:s.Z,alt:"colour wheel"}),(0,i.mdx)("p",null,"In fact we can even find out the orientation of the edges by taking the arctan of the gradient functions, ",(0,i.mdx)("inlineCode",{parentName:"p"},"Î¸ = atan(Gy/Gx)"),". The orientation can then be mapped to a colour using a colour wheel. Try running the example Sobel operation below:"),(0,i.mdx)(o.Z,{transformType:"sobelColour",mdxType:"FlowerSobel"}),(0,i.mdx)("p",null,"Wow that's pretty fancy! Notice how the edges orientation maps to that of the colour wheel."),(0,i.mdx)("p",null,"Finally have a play with the JavaScript tool below allowing you to create your own Sobel images. The saturation input controls the amount of orientational colour added. Also I've set it to scale the images to 600px for performance."),(0,i.mdx)(r.Z,{mdxType:"SobelTool"}),(0,i.mdx)("h2",null,"Further reading / watching"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{className:"blueLink",href:"https://youtu.be/uihBwtPIBxM"},"Finding the Edges (Sobel Operator) - Computerphile")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{className:"blueLink",href:"https://www.html5rocks.com/en/tutorials/canvas/imagefilters/"},"Image Filters with Canvas"))))}g.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-posts-2019-05-19-sobel-index-mdx-0d84da8274f529452e78.js.map